---
date: 2019-05-30T00:00:00Z
draft: true
lang: en
tags: [ TODO_TAGS ]
title: TODO_TITLE
type: link # image quote video text audio chat
via: "[Who](http://example.com)"
---


2019-05-30

Very much relevant for he discussions “techs” have frequently with “product”

> Summing all of this up:
>
> • Neglecting internal quality leads to rapid build up of cruft
> • This cruft slows down feature development
> • Even a great team produces cruft, but by keeping internal quality high, is able to keep it under control
> • High internal quality keeps cruft to a minimum, allowing a team to add features with less effort, time, and cost.

> Sadly, software developers usually don't do a good job of explaining this situation. (…) When thinking about internal quality, I stress that we should only approach it as an economic argument. High internal quality reduces the cost of future features, meaning that putting the time into writing good code actually reduces cost.

https://martinfowler.com/articles/is-quality-worth-cost.html 
via Steve Smith in #continuous-deliveree
https://equalexperts.slack.com/archives/C51U24LKA/p1559145505007500
[https://martinfowler.com/articles/is-quality-worth-cost.html](https://martinfowler.com/articles/is-quality-worth-cost.html)

E tangencialmente no tema, esta pérola do jbrains de como o custo de uma feature é dominado por “accidental complication” (how much the condenas-te sucks) em vez de “essencial complication” (a dificuldade intrínseca da tarefa) o que torna irrelevante estimativas por comparação com tarefas passadas, pois a primeira (“ac”) nunca é zero nem uniformemente distribuída no código: https://youtu.be/WSes_PexXcA
(não liguem mto ao sales pitch de tdd, ele vende cursos disso :wink:)
